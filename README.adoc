= Parsing math expression
:nofooter:
:sectnums:
:toc: left
:stylesheet: assets/my-stylesheet.css
:stem:

== Examples input

* Precedence
+
[cols="1,1,1"]
|===
|Input |Correct |Error

|stem:[x + 5 * y]
|stem:[x + (5 * y)]
|stem:[(x + 5) * y]
|===

* Associativity
+
[cols="1,1,1"]
|===
|Input |Correct |Error

|stem:[7 - 3 + 2]
|stem:[(7 - 3) + 2]
|stem:[7 - (3 + 2)]
|===

== Grammar for expressions

E:: Expression
T:: Term
F:: Factor

=== Variations

* stem:[E -> T + E | T - E | T]
* stem:[T -> F * T | F / T | F]
* stem:[F -> ID | "Integers" | (E) - F]

=== Tokens

* ID
+
image::assets/token_id.svg[Token: ID]

* integer
+
image::assets/token_integer.svg[Token: integer]

=== Lexical analysis

code:: function `scanToken()`
+
Scans the input and sets nextToken to point to the newly scanned token.
variable:: nextToken

OOP:: Object-Oriented Programming

=== Tree

Tree example with: stem:[-(x + 5) * 2]

image::assets/tree_example.svg[tree example]

The superclass `tree node`:

image::assets/abstract_treenode.svg[Abstract: tree node]

Infix operators:

image:assets/class_add.svg[Class: add]
image:assets/class_subtract.svg[Class: subtract]
image:assets/class_mult.svg[Class: mult]
image:assets/class_div.svg[Class: div]

Prefix unary operators:

image:assets/class_negate.svg[Class: negate]

others:

image:assets/class_integer.svg[Class: integer]
image:assets/class_id.svg[Class: id]
